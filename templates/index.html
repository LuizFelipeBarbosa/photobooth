~/Documents/photobooth/photos<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>THE OCHO Photobooth</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>THE OCHO</h1>
            <p class="subtitle">PHOTOBOOTH</p>
        </header>

        <div id="status" class="status ready">
            <span class="status-icon">üì∑</span>
            <span class="status-text">Ready to capture!</span>
        </div>

        <div id="countdown-display" class="countdown-display hidden"></div>

        <div class="buttons">
            <button id="photoBtn" class="btn btn-primary" onclick="takePhoto()">
                <span class="btn-icon">üì∏</span>
                <span class="btn-text">Single Photo</span>
            </button>
            
            <button id="stripBtn" class="btn btn-secondary" onclick="takeStrip()">
                <span class="btn-icon">üéûÔ∏è</span>
                <span class="btn-text">Photo Strip</span>
                <span class="btn-subtitle">3 Photos</span>
            </button>
        </div>

        <div style="margin-top: 1rem; width: 100%; max-width: 320px;">
            <a href="/gallery" class="btn" style="background: rgba(255,255,255,0.1); padding: 1rem; text-decoration: none;">
                <span class="btn-text" style="font-size: 1rem;">üìÇ View Gallery</span>
            </a>
        </div>

        <div class="info">
            <p>üìç Look at the computer camera!</p>
            <p>Photos will print automatically</p>
        </div>
    </div>

    <div id="flash" class="flash"></div>

    <div id="photo-modal" class="modal hidden">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal()">√ó</button>
            <h2>Great Shot! üéâ</h2>
            <div class="photo-container">
                <img id="result-photo" src="" alt="Captured Photo">
            </div>
            <p class="print-msg">Printing your photo...</p>
        </div>
    </div>

    <script>
        let polling = false;
        let countdownInterval = null;
        const COUNTDOWN_SECONDS = 3;

        async function takePhoto() {
            startFlow(3, 'üì∏ Single Photo', '/api/photo');
        }

        async function takeStrip() {
            startStripFlow();
        }

        async function startFlow(seconds, mode, apiEndpoint) {
            if (document.getElementById('photoBtn').disabled) return;
            disableButtons();
            
            // Start Backend
            const fetchPromise = fetch(apiEndpoint, { method: 'POST' });
            
            // Start Visuals (Client-side simulation ONLY for single photo for now, 
            // though ideally we'd move this to backend too. Keeping as is for minimal diff on single photo)
            await runCountdown(seconds, mode);
            
            // Processing
            updateStatus('capturing', 'üñ®Ô∏è', 'Processing & printing...');
            
            try {
                const response = await fetchPromise;
                const data = await response.json();
                handleResponse(response, data);
            } catch (error) {
                handleError();
            }
        }

        async function startStripFlow() {
            if (document.getElementById('photoBtn').disabled) return;
            disableButtons();
            
            // Start Backend - Backend now drives the timing!
            const fetchPromise = fetch('/api/strip', { method: 'POST' });
            
            // Immediately start polling to see what the backend says
            startPolling();

            try {
                const response = await fetchPromise;
                const data = await response.json();
                if (!response.ok) {
                     updateStatus('error', '‚ùå', data.message);
                     enableButtons();
                     stopPolling();
                }
            } catch (error) {
                handleError();
            }
        }

        function runCountdown(seconds, text) {
            return new Promise(resolve => {
                let remaining = seconds;
                const display = document.getElementById('countdown-display');
                display.classList.remove('hidden');
                display.textContent = remaining;
                updateStatus('capturing', 'üì∑', `${text} - Get ready!`);
                
                const interval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        display.textContent = remaining;
                        updateStatus('capturing', '‚è±Ô∏è', `${text} in ${remaining}...`);
                    } else {
                        clearInterval(interval);
                        display.textContent = 'üì∏';
                        triggerFlash();
                        updateStatus('capturing', 'üì∏', 'SNAP!');
                        setTimeout(resolve, 200); // Short pause after flash
                    }
                }, 1000);
            });
        }
        
        // Removed runGap as it's no longer needed on client side

        function handleResponse(response, data) {
            if (response.ok) {
                startPolling();
            } else {
                hideCountdown();
                updateStatus('error', '‚ùå', data.message);
                enableButtons();
            }
        }

        function handleError() {
            hideCountdown();
            updateStatus('error', '‚ùå', 'Connection error');
            enableButtons();
        }

        function triggerFlash() {
            const flash = document.getElementById('flash');
            flash.classList.add('active');
            setTimeout(() => {
                flash.classList.remove('active');
            }, 200);
        }

        function hideCountdown() {
            const display = document.getElementById('countdown-display');
            display.classList.add('hidden');
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        function startPolling() {
            if (polling) return;
            polling = true;
            poll();
        }
        
        async function poll() {
            if (!polling) return;
            
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                const display = document.getElementById('countdown-display');

                if (data.status === 'countdown') {
                    // Backend is counting down
                    const remaining = Math.ceil(data.target_timestamp - (Date.now() / 1000));
                    display.classList.remove('hidden');
                    display.textContent = remaining > 0 ? remaining : "üì∏";
                    updateStatus('capturing', '‚è±Ô∏è', data.message || `Get ready... ${remaining}`);
                    
                } else if (data.status === 'capturing') {
                    // Moment of capture
                    display.classList.remove('hidden');
                    display.textContent = 'üì∏';
                    // Only trigger flash if we haven't recently? 
                    // It might trigger every 500ms while status is 'capturing'. 
                    // That's okay, maybe simple logic:
                    if (!display.classList.contains('flashed')) {
                            triggerFlash();
                            display.classList.add('flashed');
                            setTimeout(() => display.classList.remove('flashed'), 1000);
                    }
                    updateStatus('capturing', 'üì∏', data.message);

                } else if (data.status === 'waiting') {
                    // Gap between photos
                    const remaining = Math.ceil(data.target_timestamp - (Date.now() / 1000));
                    display.classList.remove('hidden');
                    display.textContent = '‚úã';
                    updateStatus('capturing', '‚úã', `${data.message} (${remaining}s)`);

                } else if (data.status === 'processing') {
                        display.classList.remove('hidden');
                        display.textContent = 'üñ®Ô∏è';
                        updateStatus('capturing', 'üñ®Ô∏è', data.message);

                } else if (data.status === 'success') {
                    hideCountdown();
                    stopPolling();
                    
                    // Show result!
                    if (data.photo_url) {
                        showModal(data.photo_url);
                    } else {
                        updateStatus('success', 'üéâ', data.message);
                        setTimeout(() => {
                            updateStatus('ready', 'üì∑', 'Ready to capture!');
                            enableButtons();
                        }, 3000);
                    }

                } else if (data.status === 'error') {
                    hideCountdown();
                    updateStatus('error', '‚ùå', data.message);
                    stopPolling();
                    enableButtons();
                }
            } catch (error) {
                // Keep polling
            }
            
            if (polling) {
                setTimeout(poll, 200);
            }
        }

        function stopPolling() {
            polling = false;
        }

        function showModal(url) {
            const modal = document.getElementById('photo-modal');
            const img = document.getElementById('result-photo');
            img.src = url; // Removed cache busting as we use unique filenames
            modal.classList.remove('hidden');
            modal.classList.add('visible');
            
            updateStatus('success', 'üéâ', 'Printed successfully!');
        }

        function closeModal() {
            const modal = document.getElementById('photo-modal');
            modal.classList.remove('visible');
            setTimeout(() => {
                modal.classList.add('hidden');
                updateStatus('ready', 'üì∑', 'Ready to capture!');
                enableButtons();
            }, 300);
        }

        function updateStatus(type, icon, message) {
            const status = document.getElementById('status');
            status.className = 'status ' + type;
            status.querySelector('.status-icon').textContent = icon;
            status.querySelector('.status-text').textContent = message;
        }

        function disableButtons() {
            document.getElementById('photoBtn').disabled = true;
            document.getElementById('stripBtn').disabled = true;
            document.body.classList.add('busy');
        }

        function enableButtons() {
            document.getElementById('photoBtn').disabled = false;
            document.getElementById('stripBtn').disabled = false;
            document.body.classList.remove('busy');
        }

        // Check initial status
        fetch('/api/status').then(r => r.json()).then(data => {
            if (data.in_progress) {
                disableButtons();
                startPolling();
            }
        });    </script>
</body>
</html>
